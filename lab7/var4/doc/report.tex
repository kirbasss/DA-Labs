\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{amsmath, amssymb}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №~7 по курсу дискретного анализа: жадные алгоритмы} 

Выполнил студент группы 08-303 МАИ \textit{Арусланов Кирилл}. 

\subsection*{Условие}

Дано \(M\) видов пищевых добавок, каждая добавка содержит \(N\) действующих веществ в известных соотношениях. Для \(i\)-го вещества введён неизвестный коэффициент \(c_i\) (один и тот же для всех добавок), а воздействие одной мешка добавки определяется как
\[
S = c_1 a_1 + c_2 a_2 + \cdots + c_N a_N,
\]
где \(a_i\) --- количество \(i\)-го вещества в данной добавке. Биолог может измерить воздействие любой добавки, потратив один мешок этой добавки (то есть получая одно линейное уравнение для коэффициентов \(c_i\)). Каждая добавка имеет цену (стоимость мешка). Необходимо подобрать самый дешёвый набор добавок (и их номера в исходном списке), по измерениям которых можно однозначно определить все коэффициенты \(c_1,\dots,c_N\). Если это сделать невозможно (все доступные наборы дают ранг системы меньше \(N\)), вывести \(-1\). Порядок веществ в описаниях добавок одинаков, все числа неотрицательные целые и не больше 50. Известно, что \(M \le N\) не исключается (в этом случае ответ, как правило, \(-1\)).

\subsection*{Метод решения}

Идея решения опирается на линейную алгебру и свойства векторных матроидов. Каждая добавка соответствует вектору из \(\mathbb{R}^N\) (или \(\mathbb{Q}^N\)); измерение добавки даёт линейное уравнение для векторов коэффициентов \(c\). Набор измерений даёт систему линейных уравнений — и коэффициенты \(c\) однозначно определяются тогда и только тогда, когда матрица, составленная из выбранных строк (векторов добавок), имеет ранг \(N\).

Задача минимизации суммы цен при требовании получить базис пространства (полный ранг) --- классическая задача выбора минимума веса базиса в векторном матроиде. Для векторного матроида жадный алгоритм (сортировка элементов по неубыванию веса и поочерёдное включение элемента, если он увеличивает ранг множества) даёт оптимальное решение.

Реализованный алгоритм:
\begin{enumerate}
  \item Считать \(M, N\). Прочитать \(M\) строк по \(N\) чисел и цену каждой добавки.
  \item Если \(M < N\) — сразу возвращаем \(-1\).
  \item Отсортировать индексы добавок в порядке неубывания цены (при равной цене --- по возрастанию исходного индекса).
  \item Идём в отсортированном порядке: пытаемся добавить в текущее множество следующую добавку; если ранг матрицы, составленной из выбранных строк, увеличился (по сравнению с предыдущим), фиксируем добавку в ответе, иначе отбрасываем её. Останавливаемся, как только достигнут ранг \(N\) или перебраны все добавки.
  \item Если в конце размер выбранного множества меньше \(N\) — выводим \(-1\), иначе выводим номера выбранных добавок в порядке возрастания.
\end{enumerate}

Для вычисления ранга используется метод Гаусса (приведение к верхнетреугольному/строчно-редуцированному виду) с вещественной арифметикой и малым порогом \( \text{EPS}=10^{-12} \) для сравнения с нулём.

\subsection*{Описание программы}

Программа реализована в одном файле на C++. Основные компоненты:
\begin{itemize}
  \item \texttt{rank\_matrix(std::vector< std::vector< long double > > a)} --- вычисляет ранг матрицы (строки = векторы добавок). Замечание: параметр передаётся по значению, поскольку в реализации выполняются нормализация и вычитания строк; это облегчает код, но влечёт дополнительные копирования.
  \item Главный код: чтение входных данных, сортировка индексов по цене, поочерёдное добавление строк и вызов \texttt{rank\_matrix} для проверки увеличения ранга, формирование результата и вывод.
\end{itemize}

\subsection*{Дневник отладки}

Проблем при разработке не возникало, программа прошла чеккер с первой попытки.

\subsection*{Тест производительности}

Были проведены замеры на случайно сгенерированных данных (коэффициенты веществ в добавках в диапазоне \([-10,10]\), цены в \([1,1000]\), фиксированный генератор случайных чисел). Для каждой пары \((M,N)\) измерялось время полного выполнения алгоритма (включая сортировку и многократные вызовы вычисления ранга). Полученные результаты:

\begin{center}
\begin{tabular}{|c|c|r|}
\hline
 \(M\) & \(N\) & Время (ms) \\
\hline
100 & 20 & 0 \\
\hline
200 & 30 & 1 \\
\hline
400 & 40 & 3 \\
\hline
800 & 50 & 10 \\
\hline
800 & 80 & 57 \\
\hline
800 & 120 & 205 \\
\hline
\end{tabular}
\end{center}

Анализ результатов показывает, что время работы растёт быстро при увеличении \(N\). Теоретический анализ предсказывает асимптотику \(T(M,N) = O(M\cdot N^{3})\), и экспериментальная скорость увеличения времени при различных сериях измерений согласуется с этой оценкой (при фиксированном \(N\) рост по \(M\) практически линейный, при увеличении \(N\) при прочих равных — кубический рост).

\subsection*{Асимптотический анализ (коротко)}

\begin{itemize}
  \item Время сортировки индексов: \(O(M\log M)\).
  \item Основной цикл: в худшем случае для каждой из \(M\) добавок вызывается \texttt{rank\_matrix} на матрице размером до \(N\times N\). Прямой метод Гаусса на квадратной матрице \(N\times N\) работает за \(O(N^3)\).
  \item Следовательно, худшая оценка времени: \(O(M\cdot N^3)\). На практике итерации прекращаются, как только найден базис ранга \(N\), поэтому среднее время часто значительно меньше.
\end{itemize}

\subsection*{Недочёты}

Программа корректно решает поставленную задачу, однако есть места для улучшения производительности и качества реализации:
\begin{enumerate}
  \item В \texttt{rank\_matrix} матрица передаётся по значению, т.е. при каждом вызове выполняется копирование данных.
  \item Используется \texttt{long double} для устойчивости, но в большинстве практических случаев \texttt{double} даёт достаточную точность и выполняется быстрее.
  \item Можно было бы использовать \texttt{reserve()}.
\end{enumerate}

\subsection*{Выводы}

Реализованный алгоритм корректно находит минимальный по сумме цен набор добавок, достаточный для однозначного определения коэффициентов \(c_1,\dots,c_N\) (если такой набор существует). Алгоритм основан на жадной стратегии, которая допустима в силу того, что семейство независимых множеств образует матроид (векторный матроид) и жадный алгоритм минимального базиса в матроиде оптимален.

Сложность реализации невысока, но вычислительная сложность метода Гаусса даёт кубический рост по \(N\), что делает решение затратным при больших значениях числа веществ \(N\). Эксперимент подтвердил теоретическую оценку: при увеличении \(N\) время растёт кубически, а при увеличении \(M\) --- примерно линейно, до момента достижения ранга \(N\).

\end{document}